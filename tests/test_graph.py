from typing import Any
from pydantic import SerializationInfo, SerializeAsAny, SerializerFunctionWrapHandler, field_serializer
import pytest
from krnel.graph import OpSpec


class ExampleDataSource(OpSpec):
    """Example op spec for testing."""
    dataset_name: str
    import_date: str

DATA_SOURCE_A = ExampleDataSource(
    dataset_name="test",
    import_date="2023-01-01",
)
DATA_SOURCE_A__HASH = "op-PdjhDBdRqA_APc0oDl4T5fEVUVs163q6riQgiD7_eDw"
DATA_SOURCE_A__JSON = {
    "type": "ExampleDataSource",
    "dataset_name": "test",
    "import_date": "2023-01-01",
}


class DatasetDoubleSize(OpSpec):
    """Operation that doubles the size of the dataset!"""
    power_level: str = "DOUBLE"
    source_dataset: ExampleDataSource

OPERATION_A = DatasetDoubleSize(
    source_dataset=DATA_SOURCE_A,
)
OPERATION_A__HASH = "op-vkqyfTJTBehxF9jFs2WBThn8bPORzybH159wS07VFZk"
OPERATION_A__JSON = {
    "type": "DatasetDoubleSize",
    # Full serialization:
    "source_dataset": {
        "type": "ExampleDataSource",
        "dataset_name": "test",
        "import_date": "2023-01-01",
    },
    "power_level": "DOUBLE",
}
OPERATION_A__JSON_PARTIAL = {
    "type": "DatasetDoubleSize",
    # Partial serialization for hash (internal):
    "source_dataset": "op-PdjhDBdRqA_APc0oDl4T5fEVUVs163q6riQgiD7_eDw",
    "power_level": "DOUBLE",
}


def test_op_spec_immutability():
    """Test that OpSpec instances are immutable."""
    spec = DATA_SOURCE_A
    assert spec.dataset_name == "test"
    assert spec.import_date == "2023-01-01"

    # Try to mutate and expect immutability error (pydantic.ValidationError)
    from pydantic_core import ValidationError
    with pytest.raises(ValidationError):
        spec.dataset_name = "changed"


def test_op_spec_uuid():
    """Test that OpSpec generates a UUID."""
    spec = DATA_SOURCE_A
    spec2 = OPERATION_A

    # Update to match the actual UUID generated by the implementation (with 'type' included)
    assert spec.uuid == DATA_SOURCE_A__HASH
    assert spec2.uuid == OPERATION_A__HASH


def test_op_spec_uuid_consistency():
    """Test that identical specs have the same UUID."""
    spec1 = ExampleDataSource(dataset_name="test", import_date="2023-01-01")
    spec2 = ExampleDataSource(dataset_name="test", import_date="2023-01-01")
    spec3 = ExampleDataSource(dataset_name="bar", import_date="2023-01-01")

    assert spec1.uuid == DATA_SOURCE_A__HASH
    assert spec2.uuid == spec1.uuid
    assert spec3.uuid != spec1.uuid


def test_op_spec_serialization():
    """Test OpSpec serialization behavior."""
    data = DATA_SOURCE_A
    double_op = OPERATION_A

    # Test normal serialization
    normal_dict = double_op.model_dump()
    assert normal_dict == OPERATION_A__JSON

    # Test that serialization for computing UUID includes UUIDs
    hash_dict = double_op.model_dump_for_uuid()
    assert hash_dict == OPERATION_A__JSON_PARTIAL


def test_op_spec_reserialization():
    """Test that a OpSpec survives re-serialization."""
    serialized = OPERATION_A__JSON

    spec = OpSpec.model_validate(serialized)
    assert isinstance(spec, DatasetDoubleSize)
    assert isinstance(spec.source_dataset, ExampleDataSource)
    assert spec.source_dataset.dataset_name == "test"
    assert spec.uuid == OPERATION_A__HASH


def test_op_spec_uuid_identity():
    """Test that a OpSpec can be re-serialized and retains its UUID."""
    serialized = OPERATION_A__JSON

    spec = OpSpec.model_validate(serialized)
    assert isinstance(spec, DatasetDoubleSize)
    assert len({spec, OPERATION_A}) == 1 # type: ignore[reportUnhashable]


def test_op_spec_reserialization_fails():
    """Test that a OpSpec fails to deserialize if type is missing."""
    serialized = {
        "type": "DoesNotExist",
    }

    from pydantic_core import ValidationError
    with pytest.raises(ValidationError):
        OpSpec.model_validate(serialized)

@pytest.mark.filterwarnings("ignore:A custom validator")
def test_op_spec_type_field_serialization_fails():
    class InvalidOpSpec(OpSpec):
        type: str = "InvalidOpSpec"
        abc: str

    foo = InvalidOpSpec(type="InvalidOpSpec", abc="test")
    from pydantic_core import PydanticSerializationError
    with pytest.raises(PydanticSerializationError):
        foo.model_dump()


def test_op_spec_parents():
    class SomeComparison(OpSpec):
        op_a: DatasetDoubleSize
        op_b: DatasetDoubleSize

    some_comparison = SomeComparison(
        op_a=OPERATION_A,
        op_b=DatasetDoubleSize(source_dataset=DATA_SOURCE_A),
    )

    assert OPERATION_A.get_parents() == {DATA_SOURCE_A} # type: ignore[reportUnhashable]


def test_get_parents_of_type_none():
    """Test get_parents with of_type=None returns all direct parents."""

    class ParentA(OpSpec):
        foo: str
    class Child(OpSpec):
        parent: ParentA

    p = ParentA(foo="bar")
    c = Child(parent=p)
    parents = c.get_parents()
    assert parents == {p} # type: ignore[reportUnhashable]


def test_get_parents_of_type_specific():
    """Test get_parents with a specific type filters parents."""
    class ParentA(OpSpec):
        foo: str
    class ParentB(OpSpec):
        bar: int
    class Child(OpSpec):
        a: ParentA
        b: ParentB
    pa = ParentA(foo="x")
    pb = ParentB(bar=1)
    c = Child(a=pa, b=pb)
    parents_a = c.get_parents(of_type=ParentA)
    parents_b = c.get_parents(of_type=ParentB)
    assert {x for x in parents_a} == {pa} # type: ignore[reportUnhashable]
    assert {x for x in parents_b} == {pb} # type: ignore[reportUnhashable]


def test_get_parents_of_type_set():
    """Test get_parents with a set of types filters parents."""
    class ParentA(OpSpec):
        foo: str
    class ParentB(OpSpec):
        bar: int
    class Child(OpSpec):
        a: ParentA
        b: ParentB
    pa = ParentA(foo="x")
    pb = ParentB(bar=1)
    c = Child(a=pa, b=pb)
    parents = c.get_parents(of_type={ParentA, ParentB})
    assert {x for x in parents} == {pa, pb} # type: ignore[reportUnhashable]


def test_get_parents_recursive():
    """Test get_parents with recursive=True collects all ancestors."""
    class Grandparent(OpSpec):
        foo: str
    class Parent(OpSpec):
        gp: Grandparent
    class Child(OpSpec):
        p: Parent
    gp = Grandparent(foo="z")
    p = Parent(gp=gp)
    c = Child(p=p)
    parents = c.get_parents(recursive=True)
    assert {x for x in parents} == {p, gp}  # type: ignore[reportUnhashable]


def test_get_recursive_filtered_indirect_parents():
    """
    Test get_parents with recursive=True and of_type will include indirect
    parents further up in the graph.
    """
    class Grandparent(OpSpec):
        foo: str
    class Parent(OpSpec):
        gp: Grandparent
    class Child(OpSpec):
        p: Parent
    gp = Grandparent(foo="z")
    p = Parent(gp=gp)
    c = Child(p=p)
    # Passing both `of_type` and `recursive` should ensure indirect parents are included.
    filtered_parents = c.get_parents(recursive=True, of_type=Grandparent)
    assert {x for x in filtered_parents} == {gp} # type: ignore[reportUnhashable]


def test_get_parents_no_parents():
    """Test get_parents returns empty set if no parents."""
    class Standalone(OpSpec):
        foo: int
    s = Standalone(foo=1)
    assert s.get_parents() == set()


def test_polymorphic_serialization():
    """
    Test that fields of type OpSpec are serialized as their concrete types
    according to Pydantic rules.
    """
    class ParentA(OpSpec):
        foo: str
        bar: int
    class ParentB(OpSpec):
        foo: str
        bar: int
    class Child(OpSpec):
        a: OpSpec
        b1: ParentA
        b2: SerializeAsAny[OpSpec]

    pa = ParentA(foo="x", bar=2)
    pb = ParentB(foo="y", bar=3)
    c = Child(a=pa, b1=pa, b2=pb)

    serialized = c.model_dump()
    assert serialized['a'] == {'type': 'ParentA'}
    assert serialized['b1'] == {'type': 'ParentA', 'foo': 'x', 'bar': 2}
    assert serialized['b2'] == {'type': 'ParentB', 'foo': 'y', 'bar': 3}

def test_serialize_as_any_annotation_working():
    # https://github.com/pydantic/pydantic/issues/12121
    from pydantic import BaseModel, SerializeAsAny
    class User(BaseModel):
        name: str
    class UserLogin(User):
        password: str
    class OuterModel(BaseModel):
        as_any: SerializeAsAny[User]
        as_user: User

    user = UserLogin(name='pydantic', password='password')
    assert OuterModel(as_any=user, as_user=user).model_dump() == {
        'as_any': {'name': 'pydantic', 'password': 'password'},
        'as_user': {'name': 'pydantic'},
    }

@pytest.mark.skip(reason="upstream bug in pydantic")
def test_serialize_as_any_annotation_broken():
    # https://github.com/pydantic/pydantic/issues/12121
    from pydantic import BaseModel, SerializeAsAny
    class User(BaseModel):
        name: str
    class UserLogin(User):
        password: str
    class OuterModel(BaseModel):
        @field_serializer('*', mode='wrap')
        def custom_field_serializer(v: Any, nxt: SerializerFunctionWrapHandler):
            return nxt(v)
        as_any: SerializeAsAny[User]
        as_user: User

    user = UserLogin(name='pydantic', password='password')
    assert OuterModel(as_any=user, as_user=user).model_dump() == {
        'as_any': {'name': 'pydantic', 'password': 'password'},
        'as_user': {'name': 'pydantic'},
    }